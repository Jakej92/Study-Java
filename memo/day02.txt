배열: 저장공간의 나열

	1.
		변수를 여러 개 선언하면 이름도 여러 개 생긴다. 이 때 각 저장공간을 관리하기 불편하다.
		따라서 n칸 배열을 한 번만 선언하면 저장공간도 n개 생기고, 이름도 한 개이기 때문에
		관리하기 편하다.

	2.
		규칙성이 없는 값에 규칙성을 부여하기 위해서

배열의 선언
	자료형[] 배열명 = {값1, 값2, ... }; // 어떤 값을 넣을지 알 때 사용한다.
	자료형[] 배열명 = new 자료형[칸수]; // 어떤 값을 넣을지는 모르나, 몇 칸 만들지는 알 때 사용한다.
	자료형[] 배열명 = null; // 어떤 값을 넣을지도 모르고, 몇 칸 만들지도 모를 때 사용한다.

	※ new: Heap 메모리에 할당, 초기값으로 자동 초기화
	※ null: 주소의 초기값, 어떤 주소를 넣을지 모를 때 작성하는 값
	※ 자바에서 배열은 항상 Heap(동적 메모리)에 할당되기 때문에 메모리 상으로는 동적 배열만 존재한다.

배열의 구조
	int[] arData = {3, 5, 1, 2, 8};

	arData라는 이름의 저장공간 한 개 만들어지며, 여기에는 한 개의 값만 담을 수 있다.
	5개의 값을 담기 위해서는 5칸이 필요하며, 이는 Heap 메모리에 할당된다.
	5칸의 저장공간 중 첫 번째 저장공간의 주소값이 arData 저장공간으로 들어가며,
	다음 주소에 접근하기 위해서는 + n을 한다.
	예를 들어 arData + 2는 1이라는 값이 담긴 주소값이 되며, 
	*(arData + 2)는 해당 주소에 가서 읽어온 1이라는 값이 된다.
	JAVA에서는 직접 주소에 접근하는 연산자가 없기 때문에 위와 같은 식을 []로 치환하여 사용한다.
	arData[2]로 사용한다. 각각의 방 번호는 index라고 부르며, 시작주소를 가지고 있기 때문에
	인덱스 번호는 항상 0부터 시작된다.

length
	배열을 선언하면 length라는 상수가 선언되고, 해당 배열의 길이가 담긴다.
	배열명.length

배열의 사용
	int[] arData = new int[5];		// 저장공간
	arData[0] = 120;				// 저장공간
	arData[0] + 9;				// 값
	System.out.println(arData);		// 주소값
	arData[2] = arData[0] + arData[1];	// 저장공간, 값
	System.out.println(arData[5]);		// 오류
==========================================================================
2차원 배열: 배열 안에 배열
	1차원 배열을 여러 개 선언하면, 관리하기 어렵다.
	2차원 배열을 한 번만 선언하자!

	※ 2차원 배열부터는 메모리 낭비가 심하므로 선호하지 않는다.

2차원 배열 선언
	자료형[][] 배열명 = {{값1, 값2, ...}, {값3, 값4, ...}};
	자료형[][] 배열명 = new 자료형[행][열];
	자료형[][] 배열명 = null;

	int[][] arrData = new int[2][3];

	□			arrData		arrData.length: 행의 길이 
	□□			arrData[행]		arrData[행].length: 열의 길이
	□□□ □□□	arrData[행][열]	
===========================================================================
메소드
	이름 뒤에 소괄호
	단, 키워드 뒤에 소괄호는 메소드가 아니다.
	저장공간이다.

	f		(x)	=	2x + 1
	메소드	매개		리턴값
	이름		변수


메소드 선언
	(1)리턴타입 (2)메소드명 (자료형 (3)매개변수명, ...) {
		(4) 실행할 문장
		(5) return 리턴 값;
	}

	(1) 리턴 값이 있다면 리턴 값의 자료형을 작성하고, 리턴 값이 없다면 void를 작성한다.
	(2) 동사로 작성한다(연필(매개변수)을 쓴다(메소드)).
	(3) 외부에서 전달받을 값이 있다면, 자료형과 순서에 맞게 선언해준다.
	    생략이 가능하지만, 외부에서 값을 전달받을 수 없게 된다.
	(4) 생략이 가능하다. 메소드의 기능을 구현하는 로직을 작성한다.
	(5) 생략이 가능하다. 리턴 값이 있다면, 사용한 부분 통채로를 리턴값으로 봐야한다.

메소드 선언 순서
	문제) 두 정수의 덧셈 메소드 선언

	1. 메소드 이름을 생각한다.
		add(){}

	2. 매개변수를 생각한다.
		add(int number1, int number2){}

	3. 실행할 문장을 작성한다.
		add(int number1, int number2){
			int result = number1 + number2;
		}

	4. 리턴 값을 작성한다.
		add(int number1, int number2){
			int result = number1 + number2;
			return result;
		}

	5. 리턴타입을 결정한다.
		int add(int number1, int number2){
			int result = number1 + number2;
			return result;
		}

메소드 주의사항
	1. 메소드를 선언할 때 {}가 있으며, 반드시 메소드 밖에서 선언한다.
	2. 메소드를 사용할 때 {}가 없으며, 반드시 메소드 안에서 사용한다.

메소드를 사용하는 이유
	1. 재사용(특정성을 부여해서는 안된다).
	2. 소스코드 간결화
















