함수형 인터페이스(Functional Interface)
	인터페이스 중 추상 메소드를 하나만 가지고 있는 인터페이스를 함수형 인터페이스라고 한다.
	이 때 @FunctionalInterface를 인터페이스 위에 작성하여 단 하나의 추상 메소드만 선언하도록 한다.

람다식(Lambda Expression)
	함수형 인터페이스에서는 한 개의 추상 메소드만 존재하기 때문에 구현 시 메소드 이름이 딱히 필요가 없다.
	람다식은 이름이 없는 메소드로서, 값처럼 사용이 가능하고 당연히 매개변수로도 전달이 가능하다.
	따라서 람다식을 익명 메소드라고도 부른다.

람다식 문법
	1. (매개변수 형식 나열, ...) -> 리턴값;
	2. (매개변수 형식 나열, ...) -> {실행할 문장; return 리턴값;};
	3. 매개변수 -> 리턴값;
	4. 매개변수 -> {실행할 문장; return 리턴값;};

[기초 실습]
	package는 lambdaTask로 선언한다.

	PrintName 인터페이스 선언
	getFullName() 추상 메소드 선언
	- 성과 이름을 전달받는다.
	
	PrintNameTest 클래스 선언
	printFullName() 메소드 선언
	- 외부에서 구현된 PrintName을 전달받은 뒤 전체 이름을 출력
	
	main 메소드에서 printFullName()을 사용하여 테스트 진행
---------------------------------------------------------------------------------------------------------------------
예외 처리
	에러: 심각한 오류
	예외: 덜 심각한 오류

	컴파일 시, 빌드 시, 런타임 시 오류가 발생하면, 제어문 혹은 문법 교정을 통해 막을 수 있지만
	아에 막을 수 없는 상황도 발생한다. 컴퓨터에 이상이 생길 정도로 심각한 오류는 에러라고 표현하고
	프로그램에 이상이 생긴 것을 예외라고 부른다. 하지만 정해진 용어는 정확히 없으니 보통 "오류"라고 부른다.
	프로그램이 강제 종료되는 것을 막는 게 예외 처리의 목적이다. 

예외 처리 문법
	try {
		오류가 발생할 수 있는 문장;
	} 
	catch(예외이름 객체명) {
		오류 발생 시 실행할 문장;
	}
	catch(예외이름 객체명) {
		오류 발생 시 실행할 문장;
	}
	...
	finally {
		catch에서 잡히지 않은 오류가 있더라도 무조건 실행
	}

예외 발생
	직접 예외를 발생시키기 위해서는 예외 던지기를 사용해야 하며, 이 때 생성자 호출 전 throw 키워드를 사용한다.
	예) throw new BadWordException();

사용자 정의 예외
	기본적으로 제공되는 예외가 아닌 특정 상황에서 직접 예외를 만들어야 한다면,
	Exception 혹은 RuntimeException을 상속받아서 예외 클래스를 선언해야 한다.
	Exception은 컴파일러가 체크하기 때문에 예외처리를 강제로 해야하고,
	RuntimeException은 컴파일러가 체크하지 않기 때문에 예외처리를 선택할 수 있다.



















